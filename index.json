[{"content":"Log4j2的Appender充分考虑了日志事件的输出、包装以及过滤转发的可能，包括最基本的输出到本地文件、输出到远程主机， 对文件进行封装、注入，并且还能按照日志文件的时间点、文件大小等条件进行自动封存。\n官网网址:\nhttps://logging.apache.org/log4j/2.x/manual/appenders.html\n应用场景:\n想要将几个不同源的日志汇集到一起，可以用FlumeAppender； 想要在LogEvent中注入信息， 可以用RewriteAppender； 想要让系统按照设定的时间间隔自动封存日志信息，可以用RollingFileAppender （每隔一定时间自动保存一份新增的日志文件，并按照时间戳等指定格式命名）； 当产生安全级别达ERROR或FATAL的LogEvent时， 给维护人员发送邮件可用SMTPAppender； 希望将日志信息写到远程主机的，可用SocketAppender； 希望能够按照RFC5424格式向远程主机发送日志信息，可用SyslogAppender等等。 SocketAppender SocketAppender 将log event输出到一个远程服务器上（需指定服务器名和端口号），数据可以以任意指定的格式经由TCP或UDP协议发送。 SocketAppender中比较重要的参数有：\nhost，String，指定服务器的主机名。（必需）\nimmediateFlush，boolean，是否立即flush，还是等待缓存到一定大小后在flush。\nlayout，Layout，log event输出的格式。\nport，integer，远程服务器坚挺log event的应用的端口号。\nreconnectionDelay，integer，当连接断开时，延迟等待的ms数。\nname，String ，Appender的名称。\nprotocol，String，通讯协议 默认TCP。可选值 \u0026ldquo;TCP\u0026rdquo; (default), \u0026ldquo;SSL\u0026rdquo; or \u0026ldquo;UDP\u0026rdquo;.\nSSL，SslConfiguration，包含密钥存储库和信任存储库的配置.\nfilter，Filter，一个过滤器来确定事件应该由这个Appender。 不止一个过滤器 可以通过使用一个CompositeFilter。\nimmediateFail，boolean，设置为true时,日志事件不会等待尝试重新连接,将立即如果失败 套接字是不可用的。\nimmediateFlush，boolean， 当该值设置成真时,默认情况下,每个写将冲洗。 这将保证写的数据 到磁盘,但可能会影响性能。\nlayout，Layout，LogEvent ，布局使用格式。 缺省值是SerializedLayout。\nreconnectionDelay，integer ，如果设置为值大于0,一个错误后SocketManager将尝试重新连接 在指定的毫秒数后的服务器。 如果连接失败 将抛出一个异常(可以被应用程序如果ignoreExceptions是 设置为假)。\nignoreExceptions，boolean，默认值是真正的添加事件时,遇到了引起异常 内部记录,然后忽略。 当设置为假将传播到异常 调用者。 你必须设置这个假当包装这个AppenderFailoverAppender。\n配置 \u0026lt;appender name=\u0026#34;remoteFile\u0026#34; class=\u0026#34;org.apache.log4j.net.SocketAppender\u0026#34;\u0026gt;\r\u0026lt;param name=\u0026#34;remoteHost\u0026#34; value=\u0026#34;localhost\u0026#34; /\u0026gt;\u0026lt;!-- 这是远程log server --\u0026gt;\r\u0026lt;param name=\u0026#34;port\u0026#34; value=\u0026#34;4560\u0026#34; /\u0026gt;\u0026lt;!-- 这是远程log server port --\u0026gt;\r\u0026lt;param name=\u0026#34;Threshold\u0026#34; value=\u0026#34;INFO\u0026#34; /\u0026gt;\u0026lt;!-- log 级别 --\u0026gt;\r\u0026lt;param name=\u0026#34;ReconnectionDelay\u0026#34; value=\u0026#34;1000\u0026#34; /\u0026gt;\r\u0026lt;param name=\u0026#34;LocationInfo\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt;\r\u0026lt;/appender\u0026gt; ","permalink":"https://cyf1997.github.io/posts/blog/log4j/log4j-2.0%E4%B8%AD%E7%9A%84appender%E4%B9%8Bsocketappender/","summary":"Log4j 2.0中的Appender之SocketAppender","title":"Log4j 2.0中的Appender之SocketAppender"},{"content":"使用BFG清理git历史大文件 本人是后端开发，也会些前端的技术，于是就clone代码，小小代码半天也没有克隆下来，好在最后下载下来了。使用`git count-objects -vH`命令一看，发现有2G多，这是很不正常的。\rgit自带清除命令，但是比较慢，所以我们使用bfg来进行清理。\nbfg下载jar包:https://rtyley.github.io/bfg-repo-cleaner/#download\n步骤 1 打开git命令窗口 需要另起文件夹\n2 只克隆git相关的文件 git clone --mirror git@127.0.0.1:retailCredit.git 克隆完可以在文件夹中看到名为retailCredit.git的文件夹\ncd your_project.git 3 查看大小 git count-objects -vH 可以看到size-pack的大小有2.62G\n4 查看大文件 git rev-list --objects --all | grep \u0026#34;$(git verify-pack -v ./objects/pack/*.idx | sort -k 3 -n | tail -10 | awk \u0026#39;{print$1}\u0026#39;)\u0026#34; 可以看到有人把自己微信聊天记录传上来了，还有依赖包等和源码无关的东西\n5 清理文件 这里可以清理文件或者文件夹，按需清理。如上图，既有文件夹WeChat Files文件夹，还有压缩包\n5.1 清理文件夹 注意删除的是目录名称，不是路径名称\njava -jar D:\\bfg-1.14.0.jar --no-blob-protection --delete-folders \u0026#39;WeChat Files\u0026#39; 5.2 清理文件 java -jar D:\\bfg-1.14.0.jar --no-blob-protection -D node_modules.zip\rjava -jar D:\\bfg-1.14.0.jar --no-blob-protection -D permission.zip\rjava -jar D:\\bfg-1.14.0.jar --no-blob-protection -D dist.tar 6 清理脏数据 git reflog expire --expire=now --all \u0026amp;\u0026amp; git gc --prune=now --aggressive 7 再次查看文件大小 git count-objects -vH 本次清理完之后只剩下了67MB了，感觉还是大了，再查询一次发现还是有垃圾文件\ngit rev-list --objects --all | grep \u0026#34;$(git verify-pack -v ./objects/pack/*.idx | sort -k 3 -n | tail -10 | awk \u0026#39;{print$1}\u0026#39;)\u0026#34; 接下来重复步骤4至步骤7即可\n8 提交变动 git push -f 提交以后，需要重新克隆项目再进行开发\n","permalink":"https://cyf1997.github.io/posts/blog/git/%E5%A4%84%E7%90%86.git%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7%E8%87%83%E8%82%BF/","summary":"处理.git文件夹过大臃肿","title":"处理.git文件夹过大臃肿"},{"content":"Mysql 递归 在MySQL中，使用递归查询通常涉及到公用表表达式 (Common Table Expressions, CTEs)，这在MySQL 8.0及更高版本中可用。\n这篇博文中我们使用如下表结构和初始数据做试验\n表结构\nCREATE TABLE `dept` ( `dept_id` varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT \u0026#39;机构ID\u0026#39;, `dept_name` varchar(255) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \u0026#39;机构名称\u0026#39;, `parent_id` varchar(32) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \u0026#39;机构父ID\u0026#39;, `tenant_id` varchar(16) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT \u0026#39;租户编号\u0026#39;, PRIMARY KEY (`dept_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci; 初始数据\nINSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1\u0026#39;, \u0026#39;总公司\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;TEN01\u0026#39;); INSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1.1\u0026#39;, \u0026#39;产品部\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;TEN01\u0026#39;); INSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1.1.1\u0026#39;, \u0026#39;产品一部\u0026#39;, \u0026#39;1.1\u0026#39;, \u0026#39;TEN01\u0026#39;); INSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1.1.2\u0026#39;, \u0026#39;产品二部\u0026#39;, \u0026#39;1.1\u0026#39;, \u0026#39;TEN01\u0026#39;); INSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1.2\u0026#39;, \u0026#39;研发部\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;TEN01\u0026#39;); INSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1.2.1\u0026#39;, \u0026#39;研发一部\u0026#39;, \u0026#39;1.2\u0026#39;, \u0026#39;TEN01\u0026#39;); INSERT INTO `fmsdb`.`dept` (`dept_id`, `dept_name`, `parent_id`, `tenant_id`) VALUES (\u0026#39;1.2.2\u0026#39;, \u0026#39;研发二部\u0026#39;, \u0026#39;1.2\u0026#39;, \u0026#39;TEN01\u0026#39;); 查询 以下是一个使用递归CTE的MySQL示例，该示例查询了一个组织结构中的所有下属部门：\nWITH RECURSIVE cte AS ( SELECT * FROM dept WHERE parent_id = \u0026#39;0\u0026#39; AND tenant_id = \u0026#39;TEN01\u0026#39; UNION ALL SELECT d.* FROM dept d INNER JOIN cte c ON d.parent_id = c.dept_id ) SELECT * FROM cte; 在这个例子中，cte 表代表组织中的部门，其中包含两列：dept_id 和 parent_id。递归查询首先选择所有没有父部门的部门（顶级部门），然后通过UNION ALL和内部联接进行递归，将每个部门的下属部门也选择出来。\n简单点理解就是通过union all 分割为两端sql，第一段为父查询，查询结果为顶部数据，第二段为根据上级id查询出的子数据，递归将所有数据查询出。\n删除 了解了查询，递归删除也容易实现。根据上面查询的sql，只需要将查询出的结果当做子查询条件即可。\nDELETE FROM dept WHERE dept_id IN ( SELECT dept_id FROM cte ); 完整的sql如下：\nWITH RECURSIVE cte AS ( SELECT * FROM dept WHERE parent_id = \u0026#39;0\u0026#39; AND tenant_id = \u0026#39;TEN01\u0026#39; UNION ALL SELECT d.* FROM dept d INNER JOIN cte c ON d.parent_id = c.dept_id ) DELETE FROM dept WHERE dept_id IN ( SELECT dept_id FROM cte ); 新增 递归新增写法：\ninsert into table_name 递归查询语句 没错就是这么简单，注意insert into 语句在递归语句前面\n接下来的场景为多租户系统中，将租户的机构全部复制到其他租户中\nINSERT INTO dept WITH RECURSIVE cte AS ( SELECT UUID_SHORT() as \u0026#39;new_id\u0026#39;, -- 生成新的ID dept_id, dept_name, parent_id, \u0026#39;TEN02\u0026#39; AS tenant_id FROM dept WHERE parent_id = \u0026#39;0\u0026#39; AND tenant_id = \u0026#39;TEN01\u0026#39; UNION ALL SELECT UUID_SHORT() AS \u0026#39;new_id\u0026#39;, -- 对子节点也生成新的ID d.dept_id, d.dept_name, c.new_id as `patent_id`, -- 更新父ID为新生成的ID \u0026#39;TEN02\u0026#39; as tenant_id FROM dept d INNER JOIN cte c ON d.parent_id = c.dept_id ) SELECT new_id,dept_name,parent_id,tenant_id FROM cte; 上面语句是将租户编号为TEN01的数据都复制到TEN02中\n来看下执行结果\nselect * from dept where tenant_id = \u0026#39;TEN02\u0026#39; 可以看到不仅将id和parent_id修改了，同时也将tenant_id修改了\n","permalink":"https://cyf1997.github.io/posts/blog/mysql/mysql-%E9%80%92%E5%BD%92/","summary":"Mysql 递归","title":"Mysql 递归"},{"content":"mysql行列转换 行转列 创建表\nCREATE TABLE `test` ( `id` int(11) NOT NULL, `name` varchar(32) DEFAULT NULL, `subject` varchar(32) DEFAULT NULL, `score` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据\nINSERT INTO `test` VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;95\u0026#39;); INSERT INTO `test` VALUES (2, \u0026#39;张三\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;80\u0026#39;); INSERT INTO `test` VALUES (3, \u0026#39;张三\u0026#39;, \u0026#39;英语\u0026#39;, \u0026#39;75\u0026#39;); INSERT INTO `test` VALUES (4, \u0026#39;李四\u0026#39;, \u0026#39;数学\u0026#39;, \u0026#39;45\u0026#39;); INSERT INTO `test` VALUES (5, \u0026#39;李四\u0026#39;, \u0026#39;语文\u0026#39;, \u0026#39;90\u0026#39;); INSERT INTO `test` VALUES (6, \u0026#39;李四\u0026#39;, \u0026#39;英语\u0026#39;, \u0026#39;66\u0026#39;); 1.join方式 SELECT b.NAME, b.score AS \u0026#39;数学\u0026#39;, c.score AS \u0026#39;语文\u0026#39;, d.score AS \u0026#39;英语\u0026#39; FROM (SELECT score, NAME FROM test WHERE SUBJECT = \u0026#39;数学\u0026#39; ) b INNER JOIN ( SELECT score, NAME FROM test WHERE SUBJECT = \u0026#39;语文\u0026#39; ) c USING ( NAME ) INNER JOIN ( SELECT score, NAME FROM test WHERE SUBJECT = \u0026#39;英语\u0026#39; ) d USING ( NAME ) 2.case\u0026hellip;when SELECT NAME, max(case subject when \u0026#39;数学\u0026#39; then score end) as \u0026#39;数学\u0026#39;, max(case subject when \u0026#39;语文\u0026#39; then score end) as \u0026#39;语文\u0026#39;, max(case subject when \u0026#39;英语\u0026#39; then score end) as \u0026#39;英语\u0026#39; from test\tGROUP BY name 3.if SELECT NAME, sum(IF(subject=\u0026#39;数学\u0026#39;,score,0)) as \u0026#39;数学\u0026#39;, sum(IF(subject=\u0026#39;语文\u0026#39;,score,0)) as \u0026#39;语文\u0026#39;, sum(IF(subject=\u0026#39;英语\u0026#39;,score,0)) as \u0026#39;英语\u0026#39; from test\tGROUP BY name 列转行 创建表\nCREATE TABLE `test2` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `math` varchar(32) DEFAULT NULL, `chinese` varchar(32) DEFAULT NULL, `english` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; 插入数据\nINSERT INTO `test2` VALUES (1, \u0026#39;张三\u0026#39;, \u0026#39;21\u0026#39;, \u0026#39;26\u0026#39;, \u0026#39;34\u0026#39;); INSERT INTO `test2` VALUES (2, \u0026#39;李四\u0026#39;, \u0026#39;23\u0026#39;, \u0026#39;56\u0026#39;, \u0026#39;18\u0026#39;); 1.union all SELECT name,\u0026#39;数学\u0026#39; as subject , math as \u0026#39;score\u0026#39; from test2 union all SELECT name,\u0026#39;语文\u0026#39; as subject , chinese as \u0026#39;score\u0026#39; from test2 union all SELECT name,\u0026#39;英语\u0026#39; as subject , english as \u0026#39;score\u0026#39; from test2 ","permalink":"https://cyf1997.github.io/posts/blog/mysql/mysql%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2/","summary":"mysql行列转换","title":"mysql行列转换"},{"content":"FastDFS 一、介绍 二、单节点安装 如果以root用户安装，不修改任何配置，默认的脚本在/usr/bin/fdfs下，配置文件在/etc/fdfs下，但是在生产上，root账户我们不能随意去使用，所以我们需要自定义用户来使用fastdfs\n安装前准备 新建用户\nuseradd fdfs 设置用户密码\npasswd fdfs 安装依赖\nyum install gcc-c++ perl-devel pcre-devel openssl-devel zlib-devel wget 软件上传到/home/fdfs/soft\n修改权限\nchown -R fdfs:fdfs /home/fdfs/ 安装开始 全程以root用户安装 1.解压安装libfastcommon-1.0.57.tar.gz\ncd /home/fdfs/soft tar -xzvf libfastcommon-1.0.57.tar.gz cd libfastcommon-1.0.57 ./make.sh ./make.sh install 2.解压安装文件fastdfs-6.08.tar.gz\ncd /home/fdfs/soft tar -xzvf fastdfs-6.08.tar.gz cd /home/fdfs/soft/fastdfs-6.08 ./make ./make install 执行复制配置脚本，将脚本复制到/etc/fdfs下\n./setup.sh 脚本命令目录在/usr/bin下\n配置文件在/etc/fdfs下\n3.配置FastDFS跟踪器(Tracker)\n修改配置tracker.conf\nvim /etc/fdfs/tracker.conf 修改内容如下\n#tracker日志和数据目录 base_path = /data/fdfs/tracker 创建base_path目录\nmkdir -p /data/fdfs/tracker 启动Tracker\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start 查看 FastDFS Tracker 是否已成功启动\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf status 关闭Tracker命令\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop 设置Tracker开机启动\nchkconfig fdfs_trackerd on tracker server 目录及文件结构\n4.配置 FastDFS 存储 (Storage)\nvim /etc/fdfs/storage.conf 修改内容如下\n#storage的日志和数据目录 base_path=/data/fdfs/storage #实际文件存放目录 store_path0=/data/fdfs/storage/files #tracker的ip,多个就往下复制 tracker_server=ip:22122 创建对应目录\nmkdir -p /data/fdfs/storage/files 启动 Storage\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start 查看storage服务状态\nservice fdfs_storaged status 关闭Storage\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop 查看Storage和Tracker是否在通信：\n/usr/bin/fdfs_monitor /etc/fdfs/storage.conf 设置 Storage 开机启动\nchkconfig fdfs_storaged on Storage 目录\n同 Tracker，Storage 启动成功后，在base_path 下创建了data、logs目录，记录着 Storage Server 的信息。 在 store_path0/data 目录下，创建了N*N个子目录：\n[root@iZ2zej7sidrziz9jw6nozvZ data]# pwd /data/fdfs/storage/files/data [root@iZ2zej7sidrziz9jw6nozvZ data]# ls 00 06 0C 12 18 1E 24 2A 30 36 3C 42 48 4E 54 5A 60 66 6C 72 78 7E 84 8A 90 96 9C A2 A8 AE B4 BA C0 C6 CC D2 D8 DE E4 EA F0 F6 FC 01 07 0D 13 19 1F 25 2B 31 37 3D 43 49 4F 55 5B 61 67 6D 73 79 7F 85 8B 91 97 9D A3 A9 AF B5 BB C1 C7 CD D3 D9 DF E5 EB F1 F7 FD 02 08 0E 14 1A 20 26 2C 32 38 3E 44 4A 50 56 5C 62 68 6E 74 7A 80 86 8C 92 98 9E A4 AA B0 B6 BC C2 C8 CE D4 DA E0 E6 EC F2 F8 FE 03 09 0F 15 1B 21 27 2D 33 39 3F 45 4B 51 57 5D 63 69 6F 75 7B 81 87 8D 93 99 9F A5 AB B1 B7 BD C3 C9 CF D5 DB E1 E7 ED F3 F9 FF 04 0A 10 16 1C 22 28 2E 34 3A 40 46 4C 52 58 5E 64 6A 70 76 7C 82 88 8E 94 9A A0 A6 AC B2 B8 BE C4 CA D0 D6 DC E2 E8 EE F4 FA 05 0B 11 17 1D 23 29 2F 35 3B 41 47 4D 53 59 5F 65 6B 71 77 7D 83 89 8F 95 9B A1 A7 AD B3 B9 BF C5 CB D1 D7 DD E3 E9 EF F5 FB 4.配置client\n修改 Tracker 服务器中的客户端配置文件\nvim /etc/fdfs/client.conf 修改内容如下\n#client的日志和数据目录 base_path=/data/fdfs/client #tracker的ip端口 tracker_server=ip:22122 创建对应目录\nmkdir -p /data/fdfs/client 上传测试\n/usr/bin/fdfs_test /etc/fdfs/client.conf upload 1234.jpg 成功后信息\nThis is FastDFS client test program v6.08 Copyright (C) 2008, Happy Fish / YuQing FastDFS may be copied only under the terms of the GNU General Public License V3, which may be found in the FastDFS source kit. Please visit the FastDFS Home Page http://www.fastken.com/ for more detail. [2022-08-09 10:39:12] DEBUG - base_path=/data/fdfs/client, connect_timeout=5, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0 tracker_query_storage_store_list_without_group: server 1. group_name=, ip_addr=172.18.59.251, port=23000 group_name=group1, ip_addr=172.18.59.251, port=23000 storage_upload_by_filename group_name=group1, remote_filename=M00/00/00/rBI7-2LxyNCAA_omAAF1-ZVeThs421.jpg source ip address: 172.18.59.251 file timestamp=2022-08-09 10:39:12 file size=95737 file crc32=2505985563 example file url: http://172.18.59.251/group1/M00/00/00/rBI7-2LxyNCAA_omAAF1-ZVeThs421.jpg storage_upload_slave_by_filename group_name=group1, remote_filename=M00/00/00/rBI7-2LxyNCAA_omAAF1-ZVeThs421_big.jpg source ip address: 172.18.59.251 file timestamp=2022-08-09 10:39:12 file size=95737 file crc32=2505985563 example file url: http://172.18.59.251/group1/M00/00/00/rBI7-2LxyNCAA_omAAF1-ZVeThs421_big.jpg 上传成功后返回文件路径：group1/M00/00/00/rBI7-2LxyNCAA_omAAF1-ZVeThs421.jpg 返回的文件路径由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。\n5.修改权限\n默认都是用root安装的\n如果想以fdfs来维护可以修改权限\nchown -R fdfs:fdfs /usr/bin/fdfs_* chown -R fdfs:fdfs /etc/fdfs chown -R fdfs:fdfs /data/fdfs FastDFS 配置 Nginx 模块 FastDFS 通过 Tracker 服务器，将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进行文件复制， 有同步延迟的问题。\n假设 Tracker 服务器将文件上传到了 192.168.51.128，上传成功后文件 ID已经返回给客户端。\n此时 FastDFS 存储集群机制会将这个文件同步到同组存储 192.168.51.129，在文件还没有复制完成的情况下，客户端如果用这个文件 ID 在 192.168.51.129 上取文件,就会出现文件无法访问的错误。\n而 fastdfs-nginx-module 可以重定向文件链接到源服务器取文件，避免客户端由于复制延迟导致的文件无法访问错误。\n还是以root用户安装\ncd /home/fdfs/soft tar -xzvf fastdfs-nginx-module-1.22.tar.gz cd /home/fdfs/soft/fastdfs-nginx-module-1.22/src cp mod_fastdfs.conf /etc/fdfs vim /etc/fdfs/mod_fastdfs.conf mod_fastdfs.conf修改内容如下\nbase_path=/data/fdfs/mod #tracker服务的ip+端口 tracker_server=172.18.59.251:22122 #如果文件路径的uri中包含/group**，则要设置为true url_have_group_name = true #同stroage服务的store_path0 store_path0=/data/fdfs/storage/files 创建目录\nmkdir -p /data/fdfs/mod 配置nginx，添加fastdfs-nginx-module 模块 （注意如果已经安装过nginx，那么先nginx/sbin/nginx -V看下原本的配置）\n/usr/local/nginx/sbin/nginx -V 复制好结果备用\n重新编译nginx\n# 先停掉nginx服务 /usr/local/nginx/sbin/nginx -s stop #进入nginx源码目录 cd /usr/local/src/nginx-1.9.9/ #添加fastdfs-nginx-module 模块 ./configure --prefix=/usr/local/nginx --with-http_ssl_module --add-module=/home/fdfs/soft/fastdfs-nginx-module-1.22/src #重新编译安装nginx make #复制新的命令到sbin cp /usr/local/nginx/nginx-1.9.9/objs/nginx /usr/local/nginx/sbin #验证是否加载fastdfs-nginx-module模块是否 ，有如下标红部分表示成功 /usr/local/nginx/sbin/nginx -V 修改nginx.conf\n#添加如下内容 location ~/group([0-9])/M00 { ngx_fastdfs_module; } 启动nginx\n/user/local/nginx/sbin/nginx 在浏览器访问\n文件路径可以在使用fdfs_test再上传一个，复制返回的路径用来测试\nhttp://ip:port/group1/M00/00/00/rBI7-2LzrLeAOkOqAAF1-ZVeThs773_big.jpg\n","permalink":"https://cyf1997.github.io/posts/blog/fastdfs/fastdfs/","summary":"开源的轻量级分布式文件系统","title":"FastDFS 安装"}]